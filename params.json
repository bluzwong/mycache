{"name":"为Retrofit添加两级缓存","tagline":"按照缓存的法，去产生","body":"# 为Retrofit添加两级缓存\r\n\r\n```java\r\nif (!reader.useRetrofit() && !reader.useRxjava()) { return; }\r\n```\r\n以下内容需熟悉[Retrofit](https://github.com/square/retrofit)([介绍](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1109/3662.html)) & [Rxjava](https://github.com/ReactiveX/RxJava)([介绍](http://gank.io/post/560e15be2dca930e00da1083))的使用。\r\n\r\n---\r\n\r\nRetrofit使用的[okhttp](https://github.com/square/okhttp)([介绍](http://blog.csdn.net/lmj623565791/article/details/47911083))已经对网络请求进行了缓存，但是如果服务器没有支持缓存该怎么办呢？\r\n以以下接口为例:\r\n```java\r\npublic interface Api {\r\n    @GET(\"/result.php\")\r\n    Observable<Result> getResult(@Query(\"value1\") String value1, @Query(\"value2\") String value2);\r\n}\r\n\r\nApi api = new Retrofit.Builder()\r\n                .baseUrl(...)\r\n                .client(new OkHttpClient())\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\r\n                .build()\r\n                .create(Api.class);\r\n\r\n```\r\n\r\n可能会使用这种方式来操作:\r\n```java\r\nObservable<Result> network = api.getResult(...); // 从网络获取数据\r\nObservable<Result> memory = ...; // 从内存缓存获取数据\r\nObservable<Result> disk = ...; // 从硬盘缓存获取数据\r\n\r\nObservable<Result> networkWithSave = network.doOnNext(data -> {\r\n  saveToDisk(data); // 网络获取后进行缓存\r\n  cacheInMemory(data);\r\n});\r\n\r\nObservable<Result> diskWithCache = disk.doOnNext(data -> {\r\n  cacheInMemory(data); // 从硬盘缓存获取后 再缓存到内存\r\n});\r\n\r\n// 将上面的进行整合使用\r\nObservable<Result> source = Observable\r\n    .concat(memory, diskWithCache, networkWithSave)\r\n    .filter(data -> data != null)\r\n    .first();\r\n\r\n```\r\n\r\n蛤，由于Rxjava大法好以及lambda表达式，这种方式看起来不错，还挺简洁的。但是，如果有很多很多接口都要做缓存呢？岂不是每个都得经过一番这样的处理？\r\n### NUO! NUO! NUO! DON'T REPEAT YOURSELF!\r\n如果能够这样实现,是不是一颗赛艇？\r\n```java\r\npublic interface Api {\r\n    @GET(\"/result.php\")\r\n    @MyCache(timeOut = 5000)\r\n    Observable<Result> getResult(@Query(\"value1\") String value1, @Query(\"value2\") String value2);\r\n}\r\n```\r\n## 闷声发大财:\r\nbuild.gradle\r\n```groovy\r\ncompile ('com.github.bluzwong:mycache-lib:0.1.4@aar') { transitive = true }\r\n```\r\n再换一个CallAdapterFactory\r\n```java\r\nApi api = new Retrofit.Builder()\r\n                .baseUrl(...)\r\n                .client(new OkHttpClient())\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                //.addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 使用以下代替\r\n                .addCallAdapterFactory(MyCacheRxCallAdapterFactory.create(MyCacheCore.create(context)))\r\n                .build()\r\n                .create(Api.class);\r\n```\r\n使用被 @MyCache(timeOut = 5000) 注解过的方法将会进行缓存\r\n\r\n---\r\n### 很惭愧，只做了一些微小的工作。谢谢！\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}